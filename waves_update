import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import matplotlib.patches as patches
import matplotlib.collections as collections
from IPython.display import HTML


def neumann_BC_y(psi, f=0, g=0, dx=0.01):
    psi[0, :] = psi[2, :] - 2 * dx * f
    psi[-1, :] = psi[-3, :] - 2 * dx * g
    return psi


def neumann_BC_x(psi, f=0, g=0, dx=0.01):
    psi[:, 0] = psi[:, 2] - 2 * dx * f
    psi[:, -1] = psi[:, -3] - 2 * dx * g
    return psi


def dirichlet_BC_y(psi, f=0, g=0, dx=0.01):
    psi[0, :] = f
    psi[-1, :] = g
    return psi


def dirichlet_BC_x(psi, f=0, g=0, dx=0.01):
    psi[:, 0] = f
    psi[:, -1] = g
    return psi


def absorbing_BC_x(psi, psi_prev, r):
    psi[:, 0] = psi_prev[:, 1] + ((r - 1) / (r + 1)) * (psi_prev[:, 2] - psi[:, 1])
    psi[:, -1] = psi_prev[:, -2] + ((r - 1) / (r + 1)) * (psi_prev[:, -1] - psi[:, -2])
    return psi


def absorbing_BC_y(psi, psi_prev, r):
    psi[0, :] = psi_prev[1, :] + ((r - 1) / (r + 1)) * (psi_prev[2, :] - psi[1, :])
    psi[-1, :] = psi_prev[-2, :] + ((r - 1) / (r + 1)) * (psi_prev[-1, :] - psi[-2, :])
    return psi


def x_boundary_conditions(psi, psi_prev=None, xtype='n', xf=0, xg=0, dx=0, r=3):
    if xtype == 'n':
        return neumann_BC_x(psi, xf, xg, dx)
    elif xtype == 'd':
        return dirichlet_BC_x(psi, xf, xg, dx)
    elif xtype == 'a':
        return absorbing_BC_x(psi, psi_prev, r)
    raise Exception("xtype and ytype must be either 'n' or 'd' or 'a'")


def y_boundary_conditions(psi, psi_prev=None, ytype='n', yf=0, yg=0, dy=0, r=3):
    if ytype == 'n':
        return neumann_BC_y(psi, yf, yg, dy)
    elif ytype == 'd':
        return dirichlet_BC_y(psi, yf, yg, dy)
    elif ytype == 'a':
        return absorbing_BC_y(psi, psi_prev, r)
    raise Exception("xtype and ytype must be either 'n' or 'd'")


# def single_slit(psi, x, y):
#     if (single_slit_position <= x <= single_slit_position + single_slit_width and
#             (y <= 0.5 - single_slit_height / 2 or y >= 0.5 + single_slit_height / 2)):
#         return 0
#     else:
#         return psi
#
#
# def single_slit_slow(psi=None, x=None, y=None):
#     x_position = 0.65
#     width = 0.05
#     height = 0.2
#     barrier = [patches.Rectangle((x_position, 0), width, (1 - height) / 2),
#                patches.Rectangle((x_position, 0.6), width, (1 - height) / 2)]
#     patch_collection = collections.PatchCollection(barrier, color='k')
#     if psi is not None:
#         for patch in barrier:
#             if patch.contains_point((x, y)):
#                 return 0
#             else:
#                 return psi
#     else:
#         return patch_collection
#
#
# def double_slit_slow(psi=None, x=None, y=None):
#     x_position = 0.65
#     width = 0.05
#     height = 0.2
#     barrier = [patches.Rectangle((x_position, 0), width, (0.5 - height) / 2), \
#                patches.Rectangle((x_position, (0.5 - height) / 2 + height), width, (1 - height) / 2 - height / 2), \
#                patches.Rectangle((x_position, (1 - height) / 2 - 3 * height / 2), width, 1)]
#     patch_collection = collections.PatchCollection(barrier, color='k')
#     if psi is not None:
#         for patch in barrier:
#             if patch.contains_point((x, y)):
#                 return 0
#             else:
#                 return psi
#     else:
#         return patch_collection

def n_slit(psi, x, y, grid_x, grid_y, num_slits=0):
    slit_pos = .5
    slit_width = .05
    slit_length = .2

    slit_locations = 0
    for i in range(num_slits):
        slit_locations += np.heaviside((x - i/(num_slits+1)) + slit_width, 1) * np.heaviside(-(grid_x - i/(num_slits+1)) + slit_width, 1)




if __name__ == "__main__":

    nx = 101
    ny = 101
    nt = 301
    velocity = 1
    x = np.linspace(0, 1, nx)
    y = np.linspace(0, 1, ny)
    T = np.linspace(0, nt - 1, nt)
    grid_x, grid_y = np.meshgrid(x, y)
    dx = 1 / nx
    dy = 1 / ny
    dt = dx / 2

    # Initial condition options
    gaussian = False
    standing = False
    droplet = False
    standing_drop = True

    u = np.zeros([nx, ny])
    u_1 = np.zeros_like(u)
    if gaussian:
        u = np.exp(-(10 * (grid_x - 0.2)) ** 2) * np.cos(100 * grid_x)
        u_1 = np.exp(-(10 * (grid_x - 0.2 + velocity * dt)) ** 2) * np.cos(100 * (grid_x + velocity * dt))
    elif standing:
        u = np.heaviside(-grid_x, 1)
        u_1 = np.cos(100 * dt) * np.heaviside(velocity * dt - grid_x, 1)
    elif droplet:
        centers = [(.5,.5),(.1,.1),(.9,.9)]
        for center in centers:
            cx = center[0]
            cy = center[1]
            u += np.exp(-100 * ((grid_x - cx) ** 2 + (grid_y - cy) ** 2)) * \
                 np.cos(100 * np.sqrt((grid_x - cx) ** 2 + (grid_y - cy) ** 2))
            new_x = grid_x - cx + velocity * dt * (grid_x - cx) / np.sqrt(.00001 + (grid_x - cx) ** 2 + (grid_y - cy) ** 2)
            new_y = grid_y - cy + velocity * dt * (grid_y - cy) / np.sqrt(.00001 + (grid_x - cx) ** 2 + (grid_y - cy) ** 2)
            u_1 += np.exp(-100 * (new_x ** 2 + new_y ** 2)) * np.cos(100 * np.sqrt(new_x ** 2 + new_y ** 2))
    elif standing_drop:
        cx = .5
        cy = .5
        u = np.heaviside(-np.sqrt((grid_x - cx) ** 2 + (grid_y - cy) ** 2), 1)
        new_x = grid_x - cx + velocity * dt * (grid_x - cx) / np.sqrt(.00001 + (grid_x - cx) ** 2 + (grid_y - cy) ** 2)
        new_y = grid_y - cy + velocity * dt * (grid_y - cy) / np.sqrt(.00001 + (grid_x - cx) ** 2 + (grid_y - cy) ** 2)
        u_1 = np.cos(100 * dt) * np.heaviside(-np.sqrt(new_x ** 2 + new_y ** 2), 1)

    u = x_boundary_conditions(u, xtype='n')
    u = y_boundary_conditions(u, ytype='n')
    u_1 = x_boundary_conditions(u_1, xtype='n')
    u_1 = y_boundary_conditions(u_1, ytype='n')

    a = []
    for t in T:
        a.append(np.copy(u))
        u_2 = np.copy(u_1)
        u_1 = np.copy(u)
        for i in range(1, nx - 1):
            for j in range(1, ny - 1):
                u[i, j] = 2 * u_1[i, j] - u_2[i, j] + \
                          (u_1[i + 1, j] - 2 * u_1[i, j] + u_1[i - 1, j] +
                           u_1[i, j + 1] - 2 * u_1[i, j] + u_1[i, j - 1]) * (velocity * dt / dx) ** 2
                u[i, j] = n_slit(u[i, j], grid_x[i, j], grid_y[i, j], grid_x, grid_y)
        u = x_boundary_conditions(u, psi_prev=u_1, xtype='a', r=2)
        u = y_boundary_conditions(u, ytype='n')
        if standing:
            u += np.cos(100 * t * dt) * np.heaviside(-grid_x, 1)
        if standing_drop:
            u += np.cos(100 * t * dt) * np.heaviside(-np.sqrt((grid_x - cx) ** 2 + (grid_y - cy) ** 2), 1)
        if t % 100 == 0:
            print(t)

    plt.style.use('dark_background')
    fig, ax = plt.subplots()
    cax = ax.pcolormesh(x, y, a[0][:-1, :-1], vmin=-1, vmax=1, cmap='Blues')
    fig.colorbar(cax)


    def update1(i):
        cax.set_array(a[i][:-1, :-1])


    power_dist, = ax.plot(y, np.zeros_like(y), color="red", lw=2)
    def update2(i):
        power_dist.set_ydata(a[i][:, nx - 1] ** 2)


    anim1 = animation.FuncAnimation(fig, update1, frames=len(a) - 2, interval=20)
    anim2 = animation.FuncAnimation(fig, update2, frames=len(a) - 2, interval=20)
    anim1.save('single_slit.gif')
    anim2.save('power_dist.gif')
    plt.show()
